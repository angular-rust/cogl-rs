// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use ffi;
use glib::error::ErrorDomain;
use glib::translate::*;
use glib::value::FromValue;
use glib::value::FromValueOptional;
use glib::value::SetValue;
use glib::value::Value;
use glib::Quark;
use glib::StaticType;
use glib::Type;
use gobject_sys;
use std::fmt;

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum AttributeType {
    Byte,
    UnsignedByte,
    Short,
    UnsignedShort,
    Float,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for AttributeType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "AttributeType::{}",
            match *self {
                AttributeType::Byte => "Byte",
                AttributeType::UnsignedByte => "UnsignedByte",
                AttributeType::Short => "Short",
                AttributeType::UnsignedShort => "UnsignedShort",
                AttributeType::Float => "Float",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for AttributeType {
    type GlibType = ffi::CoglAttributeType;

    fn to_glib(&self) -> ffi::CoglAttributeType {
        match *self {
            AttributeType::Byte => ffi::COGL_ATTRIBUTE_TYPE_BYTE,
            AttributeType::UnsignedByte => ffi::COGL_ATTRIBUTE_TYPE_UNSIGNED_BYTE,
            AttributeType::Short => ffi::COGL_ATTRIBUTE_TYPE_SHORT,
            AttributeType::UnsignedShort => ffi::COGL_ATTRIBUTE_TYPE_UNSIGNED_SHORT,
            AttributeType::Float => ffi::COGL_ATTRIBUTE_TYPE_FLOAT,
            AttributeType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::CoglAttributeType> for AttributeType {
    fn from_glib(value: ffi::CoglAttributeType) -> Self {
        skip_assert_initialized!();
        match value {
            5120 => AttributeType::Byte,
            5121 => AttributeType::UnsignedByte,
            5122 => AttributeType::Short,
            5123 => AttributeType::UnsignedShort,
            5126 => AttributeType::Float,
            value => AttributeType::__Unknown(value),
        }
    }
}

impl StaticType for AttributeType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::cogl_attribute_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for AttributeType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for AttributeType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for AttributeType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum BitmapError {
    Failed,
    UnknownType,
    CorruptImage,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for BitmapError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "BitmapError::{}",
            match *self {
                BitmapError::Failed => "Failed",
                BitmapError::UnknownType => "UnknownType",
                BitmapError::CorruptImage => "CorruptImage",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for BitmapError {
    type GlibType = ffi::CoglBitmapError;

    fn to_glib(&self) -> ffi::CoglBitmapError {
        match *self {
            BitmapError::Failed => ffi::COGL_BITMAP_ERROR_FAILED,
            BitmapError::UnknownType => ffi::COGL_BITMAP_ERROR_UNKNOWN_TYPE,
            BitmapError::CorruptImage => ffi::COGL_BITMAP_ERROR_CORRUPT_IMAGE,
            BitmapError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::CoglBitmapError> for BitmapError {
    fn from_glib(value: ffi::CoglBitmapError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => BitmapError::Failed,
            1 => BitmapError::UnknownType,
            2 => BitmapError::CorruptImage,
            value => BitmapError::__Unknown(value),
        }
    }
}

impl ErrorDomain for BitmapError {
    fn domain() -> Quark {
        skip_assert_initialized!();
        unsafe { from_glib(ffi::cogl_bitmap_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(BitmapError::Failed),
            1 => Some(BitmapError::UnknownType),
            2 => Some(BitmapError::CorruptImage),
            _ => Some(BitmapError::Failed),
        }
    }
}

impl StaticType for BitmapError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::cogl_bitmap_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for BitmapError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for BitmapError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for BitmapError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum BlendStringError {
    ParseError,
    ArgumentParseError,
    InvalidError,
    GpuUnsupportedError,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for BlendStringError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "BlendStringError::{}",
            match *self {
                BlendStringError::ParseError => "ParseError",
                BlendStringError::ArgumentParseError => "ArgumentParseError",
                BlendStringError::InvalidError => "InvalidError",
                BlendStringError::GpuUnsupportedError => "GpuUnsupportedError",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for BlendStringError {
    type GlibType = ffi::CoglBlendStringError;

    fn to_glib(&self) -> ffi::CoglBlendStringError {
        match *self {
            BlendStringError::ParseError => ffi::COGL_BLEND_STRING_ERROR_PARSE_ERROR,
            BlendStringError::ArgumentParseError => {
                ffi::COGL_BLEND_STRING_ERROR_ARGUMENT_PARSE_ERROR
            }
            BlendStringError::InvalidError => ffi::COGL_BLEND_STRING_ERROR_INVALID_ERROR,
            BlendStringError::GpuUnsupportedError => {
                ffi::COGL_BLEND_STRING_ERROR_GPU_UNSUPPORTED_ERROR
            }
            BlendStringError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::CoglBlendStringError> for BlendStringError {
    fn from_glib(value: ffi::CoglBlendStringError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => BlendStringError::ParseError,
            1 => BlendStringError::ArgumentParseError,
            2 => BlendStringError::InvalidError,
            3 => BlendStringError::GpuUnsupportedError,
            value => BlendStringError::__Unknown(value),
        }
    }
}

impl ErrorDomain for BlendStringError {
    fn domain() -> Quark {
        skip_assert_initialized!();
        unsafe { from_glib(ffi::cogl_blend_string_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(BlendStringError::ParseError),
            1 => Some(BlendStringError::ArgumentParseError),
            2 => Some(BlendStringError::InvalidError),
            3 => Some(BlendStringError::GpuUnsupportedError),
            value => Some(BlendStringError::__Unknown(value)),
        }
    }
}

impl StaticType for BlendStringError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::cogl_blend_string_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for BlendStringError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for BlendStringError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for BlendStringError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum DepthTestFunction {
    Never,
    Less,
    Equal,
    Lequal,
    Greater,
    Notequal,
    Gequal,
    Always,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for DepthTestFunction {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "DepthTestFunction::{}",
            match *self {
                DepthTestFunction::Never => "Never",
                DepthTestFunction::Less => "Less",
                DepthTestFunction::Equal => "Equal",
                DepthTestFunction::Lequal => "Lequal",
                DepthTestFunction::Greater => "Greater",
                DepthTestFunction::Notequal => "Notequal",
                DepthTestFunction::Gequal => "Gequal",
                DepthTestFunction::Always => "Always",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for DepthTestFunction {
    type GlibType = ffi::CoglDepthTestFunction;

    fn to_glib(&self) -> ffi::CoglDepthTestFunction {
        match *self {
            DepthTestFunction::Never => ffi::COGL_DEPTH_TEST_FUNCTION_NEVER,
            DepthTestFunction::Less => ffi::COGL_DEPTH_TEST_FUNCTION_LESS,
            DepthTestFunction::Equal => ffi::COGL_DEPTH_TEST_FUNCTION_EQUAL,
            DepthTestFunction::Lequal => ffi::COGL_DEPTH_TEST_FUNCTION_LEQUAL,
            DepthTestFunction::Greater => ffi::COGL_DEPTH_TEST_FUNCTION_GREATER,
            DepthTestFunction::Notequal => ffi::COGL_DEPTH_TEST_FUNCTION_NOTEQUAL,
            DepthTestFunction::Gequal => ffi::COGL_DEPTH_TEST_FUNCTION_GEQUAL,
            DepthTestFunction::Always => ffi::COGL_DEPTH_TEST_FUNCTION_ALWAYS,
            DepthTestFunction::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::CoglDepthTestFunction> for DepthTestFunction {
    fn from_glib(value: ffi::CoglDepthTestFunction) -> Self {
        skip_assert_initialized!();
        match value {
            512 => DepthTestFunction::Never,
            513 => DepthTestFunction::Less,
            514 => DepthTestFunction::Equal,
            515 => DepthTestFunction::Lequal,
            516 => DepthTestFunction::Greater,
            517 => DepthTestFunction::Notequal,
            518 => DepthTestFunction::Gequal,
            519 => DepthTestFunction::Always,
            value => DepthTestFunction::__Unknown(value),
        }
    }
}

impl StaticType for DepthTestFunction {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::cogl_depth_test_function_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for DepthTestFunction {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for DepthTestFunction {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for DepthTestFunction {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum FilterReturn {
    Continue,
    Remove,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for FilterReturn {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "FilterReturn::{}",
            match *self {
                FilterReturn::Continue => "Continue",
                FilterReturn::Remove => "Remove",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for FilterReturn {
    type GlibType = ffi::CoglFilterReturn;

    fn to_glib(&self) -> ffi::CoglFilterReturn {
        match *self {
            FilterReturn::Continue => ffi::COGL_FILTER_CONTINUE,
            FilterReturn::Remove => ffi::COGL_FILTER_REMOVE,
            FilterReturn::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::CoglFilterReturn> for FilterReturn {
    fn from_glib(value: ffi::CoglFilterReturn) -> Self {
        skip_assert_initialized!();
        match value {
            0 => FilterReturn::Continue,
            1 => FilterReturn::Remove,
            value => FilterReturn::__Unknown(value),
        }
    }
}

impl StaticType for FilterReturn {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::cogl_filter_return_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for FilterReturn {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for FilterReturn {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for FilterReturn {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum FogMode {
    Linear,
    Exponential,
    ExponentialSquared,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for FogMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "FogMode::{}",
            match *self {
                FogMode::Linear => "Linear",
                FogMode::Exponential => "Exponential",
                FogMode::ExponentialSquared => "ExponentialSquared",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for FogMode {
    type GlibType = ffi::CoglFogMode;

    fn to_glib(&self) -> ffi::CoglFogMode {
        match *self {
            FogMode::Linear => ffi::COGL_FOG_MODE_LINEAR,
            FogMode::Exponential => ffi::COGL_FOG_MODE_EXPONENTIAL,
            FogMode::ExponentialSquared => ffi::COGL_FOG_MODE_EXPONENTIAL_SQUARED,
            FogMode::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::CoglFogMode> for FogMode {
    fn from_glib(value: ffi::CoglFogMode) -> Self {
        skip_assert_initialized!();
        match value {
            0 => FogMode::Linear,
            1 => FogMode::Exponential,
            2 => FogMode::ExponentialSquared,
            value => FogMode::__Unknown(value),
        }
    }
}

impl StaticType for FogMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::cogl_fog_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for FogMode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for FogMode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for FogMode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum IndicesType {
    Byte,
    Short,
    Int,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for IndicesType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "IndicesType::{}",
            match *self {
                IndicesType::Byte => "Byte",
                IndicesType::Short => "Short",
                IndicesType::Int => "Int",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for IndicesType {
    type GlibType = ffi::CoglIndicesType;

    fn to_glib(&self) -> ffi::CoglIndicesType {
        match *self {
            IndicesType::Byte => ffi::COGL_INDICES_TYPE_UNSIGNED_BYTE,
            IndicesType::Short => ffi::COGL_INDICES_TYPE_UNSIGNED_SHORT,
            IndicesType::Int => ffi::COGL_INDICES_TYPE_UNSIGNED_INT,
            IndicesType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::CoglIndicesType> for IndicesType {
    fn from_glib(value: ffi::CoglIndicesType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => IndicesType::Byte,
            1 => IndicesType::Short,
            2 => IndicesType::Int,
            value => IndicesType::__Unknown(value),
        }
    }
}

impl StaticType for IndicesType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::cogl_indices_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for IndicesType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for IndicesType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for IndicesType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum MaterialAlphaFunc {
    Never,
    Less,
    Equal,
    Lequal,
    Greater,
    Notequal,
    Gequal,
    Always,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for MaterialAlphaFunc {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "MaterialAlphaFunc::{}",
            match *self {
                MaterialAlphaFunc::Never => "Never",
                MaterialAlphaFunc::Less => "Less",
                MaterialAlphaFunc::Equal => "Equal",
                MaterialAlphaFunc::Lequal => "Lequal",
                MaterialAlphaFunc::Greater => "Greater",
                MaterialAlphaFunc::Notequal => "Notequal",
                MaterialAlphaFunc::Gequal => "Gequal",
                MaterialAlphaFunc::Always => "Always",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for MaterialAlphaFunc {
    type GlibType = ffi::CoglMaterialAlphaFunc;

    fn to_glib(&self) -> ffi::CoglMaterialAlphaFunc {
        match *self {
            MaterialAlphaFunc::Never => ffi::COGL_MATERIAL_ALPHA_FUNC_NEVER,
            MaterialAlphaFunc::Less => ffi::COGL_MATERIAL_ALPHA_FUNC_LESS,
            MaterialAlphaFunc::Equal => ffi::COGL_MATERIAL_ALPHA_FUNC_EQUAL,
            MaterialAlphaFunc::Lequal => ffi::COGL_MATERIAL_ALPHA_FUNC_LEQUAL,
            MaterialAlphaFunc::Greater => ffi::COGL_MATERIAL_ALPHA_FUNC_GREATER,
            MaterialAlphaFunc::Notequal => ffi::COGL_MATERIAL_ALPHA_FUNC_NOTEQUAL,
            MaterialAlphaFunc::Gequal => ffi::COGL_MATERIAL_ALPHA_FUNC_GEQUAL,
            MaterialAlphaFunc::Always => ffi::COGL_MATERIAL_ALPHA_FUNC_ALWAYS,
            MaterialAlphaFunc::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::CoglMaterialAlphaFunc> for MaterialAlphaFunc {
    fn from_glib(value: ffi::CoglMaterialAlphaFunc) -> Self {
        skip_assert_initialized!();
        match value {
            512 => MaterialAlphaFunc::Never,
            513 => MaterialAlphaFunc::Less,
            514 => MaterialAlphaFunc::Equal,
            515 => MaterialAlphaFunc::Lequal,
            516 => MaterialAlphaFunc::Greater,
            517 => MaterialAlphaFunc::Notequal,
            518 => MaterialAlphaFunc::Gequal,
            519 => MaterialAlphaFunc::Always,
            value => MaterialAlphaFunc::__Unknown(value),
        }
    }
}

impl StaticType for MaterialAlphaFunc {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::cogl_material_alpha_func_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for MaterialAlphaFunc {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for MaterialAlphaFunc {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for MaterialAlphaFunc {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum MaterialFilter {
    Nearest,
    Linear,
    NearestMipmapNearest,
    LinearMipmapNearest,
    NearestMipmapLinear,
    LinearMipmapLinear,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for MaterialFilter {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "MaterialFilter::{}",
            match *self {
                MaterialFilter::Nearest => "Nearest",
                MaterialFilter::Linear => "Linear",
                MaterialFilter::NearestMipmapNearest => "NearestMipmapNearest",
                MaterialFilter::LinearMipmapNearest => "LinearMipmapNearest",
                MaterialFilter::NearestMipmapLinear => "NearestMipmapLinear",
                MaterialFilter::LinearMipmapLinear => "LinearMipmapLinear",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for MaterialFilter {
    type GlibType = ffi::CoglMaterialFilter;

    fn to_glib(&self) -> ffi::CoglMaterialFilter {
        match *self {
            MaterialFilter::Nearest => ffi::COGL_MATERIAL_FILTER_NEAREST,
            MaterialFilter::Linear => ffi::COGL_MATERIAL_FILTER_LINEAR,
            MaterialFilter::NearestMipmapNearest => {
                ffi::COGL_MATERIAL_FILTER_NEAREST_MIPMAP_NEAREST
            }
            MaterialFilter::LinearMipmapNearest => {
                ffi::COGL_MATERIAL_FILTER_LINEAR_MIPMAP_NEAREST
            }
            MaterialFilter::NearestMipmapLinear => {
                ffi::COGL_MATERIAL_FILTER_NEAREST_MIPMAP_LINEAR
            }
            MaterialFilter::LinearMipmapLinear => {
                ffi::COGL_MATERIAL_FILTER_LINEAR_MIPMAP_LINEAR
            }
            MaterialFilter::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::CoglMaterialFilter> for MaterialFilter {
    fn from_glib(value: ffi::CoglMaterialFilter) -> Self {
        skip_assert_initialized!();
        match value {
            9728 => MaterialFilter::Nearest,
            9729 => MaterialFilter::Linear,
            9984 => MaterialFilter::NearestMipmapNearest,
            9985 => MaterialFilter::LinearMipmapNearest,
            9986 => MaterialFilter::NearestMipmapLinear,
            9987 => MaterialFilter::LinearMipmapLinear,
            value => MaterialFilter::__Unknown(value),
        }
    }
}

impl StaticType for MaterialFilter {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::cogl_material_filter_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for MaterialFilter {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for MaterialFilter {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for MaterialFilter {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum MaterialLayerType {
    Texture,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for MaterialLayerType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "MaterialLayerType::{}",
            match *self {
                MaterialLayerType::Texture => "Texture",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for MaterialLayerType {
    type GlibType = ffi::CoglMaterialLayerType;

    fn to_glib(&self) -> ffi::CoglMaterialLayerType {
        match *self {
            MaterialLayerType::Texture => ffi::COGL_MATERIAL_LAYER_TYPE_TEXTURE,
            MaterialLayerType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::CoglMaterialLayerType> for MaterialLayerType {
    fn from_glib(value: ffi::CoglMaterialLayerType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => MaterialLayerType::Texture,
            value => MaterialLayerType::__Unknown(value),
        }
    }
}

impl StaticType for MaterialLayerType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::cogl_material_layer_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for MaterialLayerType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for MaterialLayerType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for MaterialLayerType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum MaterialWrapMode {
    Repeat,
    ClampToEdge,
    Automatic,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for MaterialWrapMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "MaterialWrapMode::{}",
            match *self {
                MaterialWrapMode::Repeat => "Repeat",
                MaterialWrapMode::ClampToEdge => "ClampToEdge",
                MaterialWrapMode::Automatic => "Automatic",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for MaterialWrapMode {
    type GlibType = ffi::CoglMaterialWrapMode;

    fn to_glib(&self) -> ffi::CoglMaterialWrapMode {
        match *self {
            MaterialWrapMode::Repeat => ffi::COGL_MATERIAL_WRAP_MODE_REPEAT,
            MaterialWrapMode::ClampToEdge => ffi::COGL_MATERIAL_WRAP_MODE_CLAMP_TO_EDGE,
            MaterialWrapMode::Automatic => ffi::COGL_MATERIAL_WRAP_MODE_AUTOMATIC,
            MaterialWrapMode::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::CoglMaterialWrapMode> for MaterialWrapMode {
    fn from_glib(value: ffi::CoglMaterialWrapMode) -> Self {
        skip_assert_initialized!();
        match value {
            10497 => MaterialWrapMode::Repeat,
            33071 => MaterialWrapMode::ClampToEdge,
            519 => MaterialWrapMode::Automatic,
            value => MaterialWrapMode::__Unknown(value),
        }
    }
}

impl StaticType for MaterialWrapMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::cogl_material_wrap_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for MaterialWrapMode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for MaterialWrapMode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for MaterialWrapMode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum PixelFormat {
    Any,
    A8,
    Rgb565,
    Rgba4444,
    Rgba5551,
    Yuv,
    G8,
    Rg88,
    Rgb888,
    Bgr888,
    Rgba8888,
    Bgra8888,
    Argb8888,
    Abgr8888,
    Rgba1010102,
    Bgra1010102,
    Argb2101010,
    Abgr2101010,
    Rgba8888Pre,
    Bgra8888Pre,
    Argb8888Pre,
    Abgr8888Pre,
    Rgba4444Pre,
    Rgba5551Pre,
    Rgba1010102Pre,
    Bgra1010102Pre,
    Argb2101010Pre,
    Abgr2101010Pre,
    Depth16,
    Depth32,
    Depth24Stencil8,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PixelFormat {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PixelFormat::{}",
            match *self {
                PixelFormat::Any => "Any",
                PixelFormat::A8 => "A8",
                PixelFormat::Rgb565 => "Rgb565",
                PixelFormat::Rgba4444 => "Rgba4444",
                PixelFormat::Rgba5551 => "Rgba5551",
                PixelFormat::Yuv => "Yuv",
                PixelFormat::G8 => "G8",
                PixelFormat::Rg88 => "Rg88",
                PixelFormat::Rgb888 => "Rgb888",
                PixelFormat::Bgr888 => "Bgr888",
                PixelFormat::Rgba8888 => "Rgba8888",
                PixelFormat::Bgra8888 => "Bgra8888",
                PixelFormat::Argb8888 => "Argb8888",
                PixelFormat::Abgr8888 => "Abgr8888",
                PixelFormat::Rgba1010102 => "Rgba1010102",
                PixelFormat::Bgra1010102 => "Bgra1010102",
                PixelFormat::Argb2101010 => "Argb2101010",
                PixelFormat::Abgr2101010 => "Abgr2101010",
                PixelFormat::Rgba8888Pre => "Rgba8888Pre",
                PixelFormat::Bgra8888Pre => "Bgra8888Pre",
                PixelFormat::Argb8888Pre => "Argb8888Pre",
                PixelFormat::Abgr8888Pre => "Abgr8888Pre",
                PixelFormat::Rgba4444Pre => "Rgba4444Pre",
                PixelFormat::Rgba5551Pre => "Rgba5551Pre",
                PixelFormat::Rgba1010102Pre => "Rgba1010102Pre",
                PixelFormat::Bgra1010102Pre => "Bgra1010102Pre",
                PixelFormat::Argb2101010Pre => "Argb2101010Pre",
                PixelFormat::Abgr2101010Pre => "Abgr2101010Pre",
                PixelFormat::Depth16 => "Depth16",
                PixelFormat::Depth32 => "Depth32",
                PixelFormat::Depth24Stencil8 => "Depth24Stencil8",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for PixelFormat {
    type GlibType = ffi::CoglPixelFormat;

    fn to_glib(&self) -> ffi::CoglPixelFormat {
        match *self {
            PixelFormat::Any => ffi::COGL_PIXEL_FORMAT_ANY,
            PixelFormat::A8 => ffi::COGL_PIXEL_FORMAT_A_8,
            PixelFormat::Rgb565 => ffi::COGL_PIXEL_FORMAT_RGB_565,
            PixelFormat::Rgba4444 => ffi::COGL_PIXEL_FORMAT_RGBA_4444,
            PixelFormat::Rgba5551 => ffi::COGL_PIXEL_FORMAT_RGBA_5551,
            PixelFormat::Yuv => ffi::COGL_PIXEL_FORMAT_YUV,
            PixelFormat::G8 => ffi::COGL_PIXEL_FORMAT_G_8,
            PixelFormat::Rg88 => ffi::COGL_PIXEL_FORMAT_RG_88,
            PixelFormat::Rgb888 => ffi::COGL_PIXEL_FORMAT_RGB_888,
            PixelFormat::Bgr888 => ffi::COGL_PIXEL_FORMAT_BGR_888,
            PixelFormat::Rgba8888 => ffi::COGL_PIXEL_FORMAT_RGBA_8888,
            PixelFormat::Bgra8888 => ffi::COGL_PIXEL_FORMAT_BGRA_8888,
            PixelFormat::Argb8888 => ffi::COGL_PIXEL_FORMAT_ARGB_8888,
            PixelFormat::Abgr8888 => ffi::COGL_PIXEL_FORMAT_ABGR_8888,
            PixelFormat::Rgba1010102 => ffi::COGL_PIXEL_FORMAT_RGBA_1010102,
            PixelFormat::Bgra1010102 => ffi::COGL_PIXEL_FORMAT_BGRA_1010102,
            PixelFormat::Argb2101010 => ffi::COGL_PIXEL_FORMAT_ARGB_2101010,
            PixelFormat::Abgr2101010 => ffi::COGL_PIXEL_FORMAT_ABGR_2101010,
            PixelFormat::Rgba8888Pre => ffi::COGL_PIXEL_FORMAT_RGBA_8888_PRE,
            PixelFormat::Bgra8888Pre => ffi::COGL_PIXEL_FORMAT_BGRA_8888_PRE,
            PixelFormat::Argb8888Pre => ffi::COGL_PIXEL_FORMAT_ARGB_8888_PRE,
            PixelFormat::Abgr8888Pre => ffi::COGL_PIXEL_FORMAT_ABGR_8888_PRE,
            PixelFormat::Rgba4444Pre => ffi::COGL_PIXEL_FORMAT_RGBA_4444_PRE,
            PixelFormat::Rgba5551Pre => ffi::COGL_PIXEL_FORMAT_RGBA_5551_PRE,
            PixelFormat::Rgba1010102Pre => ffi::COGL_PIXEL_FORMAT_RGBA_1010102_PRE,
            PixelFormat::Bgra1010102Pre => ffi::COGL_PIXEL_FORMAT_BGRA_1010102_PRE,
            PixelFormat::Argb2101010Pre => ffi::COGL_PIXEL_FORMAT_ARGB_2101010_PRE,
            PixelFormat::Abgr2101010Pre => ffi::COGL_PIXEL_FORMAT_ABGR_2101010_PRE,
            PixelFormat::Depth16 => ffi::COGL_PIXEL_FORMAT_DEPTH_16,
            PixelFormat::Depth32 => ffi::COGL_PIXEL_FORMAT_DEPTH_32,
            PixelFormat::Depth24Stencil8 => ffi::COGL_PIXEL_FORMAT_DEPTH_24_STENCIL_8,
            PixelFormat::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::CoglPixelFormat> for PixelFormat {
    fn from_glib(value: ffi::CoglPixelFormat) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PixelFormat::Any,
            17 => PixelFormat::A8,
            4 => PixelFormat::Rgb565,
            21 => PixelFormat::Rgba4444,
            22 => PixelFormat::Rgba5551,
            7 => PixelFormat::Yuv,
            8 => PixelFormat::G8,
            9 => PixelFormat::Rg88,
            2 => PixelFormat::Rgb888,
            34 => PixelFormat::Bgr888,
            19 => PixelFormat::Rgba8888,
            51 => PixelFormat::Bgra8888,
            83 => PixelFormat::Argb8888,
            115 => PixelFormat::Abgr8888,
            29 => PixelFormat::Rgba1010102,
            61 => PixelFormat::Bgra1010102,
            93 => PixelFormat::Argb2101010,
            125 => PixelFormat::Abgr2101010,
            147 => PixelFormat::Rgba8888Pre,
            179 => PixelFormat::Bgra8888Pre,
            211 => PixelFormat::Argb8888Pre,
            243 => PixelFormat::Abgr8888Pre,
            149 => PixelFormat::Rgba4444Pre,
            150 => PixelFormat::Rgba5551Pre,
            157 => PixelFormat::Rgba1010102Pre,
            189 => PixelFormat::Bgra1010102Pre,
            221 => PixelFormat::Argb2101010Pre,
            253 => PixelFormat::Abgr2101010Pre,
            265 => PixelFormat::Depth16,
            259 => PixelFormat::Depth32,
            771 => PixelFormat::Depth24Stencil8,
            value => PixelFormat::__Unknown(value),
        }
    }
}

impl StaticType for PixelFormat {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::cogl_pixel_format_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PixelFormat {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PixelFormat {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PixelFormat {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum RendererError {
    XlibDisplayOpen,
    BadConstraint,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for RendererError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "RendererError::{}",
            match *self {
                RendererError::XlibDisplayOpen => "XlibDisplayOpen",
                RendererError::BadConstraint => "BadConstraint",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for RendererError {
    type GlibType = ffi::CoglRendererError;

    fn to_glib(&self) -> ffi::CoglRendererError {
        match *self {
            RendererError::XlibDisplayOpen => ffi::COGL_RENDERER_ERROR_XLIB_DISPLAY_OPEN,
            RendererError::BadConstraint => ffi::COGL_RENDERER_ERROR_BAD_CONSTRAINT,
            RendererError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::CoglRendererError> for RendererError {
    fn from_glib(value: ffi::CoglRendererError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => RendererError::XlibDisplayOpen,
            1 => RendererError::BadConstraint,
            value => RendererError::__Unknown(value),
        }
    }
}

impl StaticType for RendererError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::cogl_renderer_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for RendererError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for RendererError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for RendererError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum ShaderType {
    Vertex,
    Fragment,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ShaderType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ShaderType::{}",
            match *self {
                ShaderType::Vertex => "Vertex",
                ShaderType::Fragment => "Fragment",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for ShaderType {
    type GlibType = ffi::CoglShaderType;

    fn to_glib(&self) -> ffi::CoglShaderType {
        match *self {
            ShaderType::Vertex => ffi::COGL_SHADER_TYPE_VERTEX,
            ShaderType::Fragment => ffi::COGL_SHADER_TYPE_FRAGMENT,
            ShaderType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::CoglShaderType> for ShaderType {
    fn from_glib(value: ffi::CoglShaderType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ShaderType::Vertex,
            1 => ShaderType::Fragment,
            value => ShaderType::__Unknown(value),
        }
    }
}

impl StaticType for ShaderType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::cogl_shader_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ShaderType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ShaderType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ShaderType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum StereoMode {
    Both,
    Left,
    Right,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for StereoMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "StereoMode::{}",
            match *self {
                StereoMode::Both => "Both",
                StereoMode::Left => "Left",
                StereoMode::Right => "Right",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for StereoMode {
    type GlibType = ffi::CoglStereoMode;

    fn to_glib(&self) -> ffi::CoglStereoMode {
        match *self {
            StereoMode::Both => ffi::COGL_STEREO_BOTH,
            StereoMode::Left => ffi::COGL_STEREO_LEFT,
            StereoMode::Right => ffi::COGL_STEREO_RIGHT,
            StereoMode::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::CoglStereoMode> for StereoMode {
    fn from_glib(value: ffi::CoglStereoMode) -> Self {
        skip_assert_initialized!();
        match value {
            0 => StereoMode::Both,
            1 => StereoMode::Left,
            2 => StereoMode::Right,
            value => StereoMode::__Unknown(value),
        }
    }
}

impl StaticType for StereoMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::cogl_stereo_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for StereoMode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for StereoMode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for StereoMode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum SystemError {
    CoglSystemErrorUnsupported,
    CoglSystemErrorNoMemory,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SystemError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SystemError::{}",
            match *self {
                SystemError::CoglSystemErrorUnsupported => "CoglSystemErrorUnsupported",
                SystemError::CoglSystemErrorNoMemory => "CoglSystemErrorNoMemory",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for SystemError {
    type GlibType = ffi::CoglSystemError;

    fn to_glib(&self) -> ffi::CoglSystemError {
        match *self {
            SystemError::CoglSystemErrorUnsupported => ffi::COGL_SYSTEM_ERROR_UNSUPPORTED,
            SystemError::CoglSystemErrorNoMemory => ffi::COGL_SYSTEM_ERROR_NO_MEMORY,
            SystemError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::CoglSystemError> for SystemError {
    fn from_glib(value: ffi::CoglSystemError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => SystemError::CoglSystemErrorUnsupported,
            1 => SystemError::CoglSystemErrorNoMemory,
            value => SystemError::__Unknown(value),
        }
    }
}

impl StaticType for SystemError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::cogl_system_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SystemError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SystemError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SystemError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum TextureComponents {
    A,
    Rg,
    Rgb,
    Rgba,
    Depth,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for TextureComponents {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "TextureComponents::{}",
            match *self {
                TextureComponents::A => "A",
                TextureComponents::Rg => "Rg",
                TextureComponents::Rgb => "Rgb",
                TextureComponents::Rgba => "Rgba",
                TextureComponents::Depth => "Depth",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for TextureComponents {
    type GlibType = ffi::CoglTextureComponents;

    fn to_glib(&self) -> ffi::CoglTextureComponents {
        match *self {
            TextureComponents::A => ffi::COGL_TEXTURE_COMPONENTS_A,
            TextureComponents::Rg => ffi::COGL_TEXTURE_COMPONENTS_RG,
            TextureComponents::Rgb => ffi::COGL_TEXTURE_COMPONENTS_RGB,
            TextureComponents::Rgba => ffi::COGL_TEXTURE_COMPONENTS_RGBA,
            TextureComponents::Depth => ffi::COGL_TEXTURE_COMPONENTS_DEPTH,
            TextureComponents::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::CoglTextureComponents> for TextureComponents {
    fn from_glib(value: ffi::CoglTextureComponents) -> Self {
        skip_assert_initialized!();
        match value {
            1 => TextureComponents::A,
            2 => TextureComponents::Rg,
            3 => TextureComponents::Rgb,
            4 => TextureComponents::Rgba,
            5 => TextureComponents::Depth,
            value => TextureComponents::__Unknown(value),
        }
    }
}

impl StaticType for TextureComponents {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::cogl_texture_components_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for TextureComponents {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for TextureComponents {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for TextureComponents {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum TextureError {
    Size,
    Format,
    BadParameter,
    Type,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for TextureError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "TextureError::{}",
            match *self {
                TextureError::Size => "Size",
                TextureError::Format => "Format",
                TextureError::BadParameter => "BadParameter",
                TextureError::Type => "Type",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for TextureError {
    type GlibType = ffi::CoglTextureError;

    fn to_glib(&self) -> ffi::CoglTextureError {
        match *self {
            TextureError::Size => ffi::COGL_TEXTURE_ERROR_SIZE,
            TextureError::Format => ffi::COGL_TEXTURE_ERROR_FORMAT,
            TextureError::BadParameter => ffi::COGL_TEXTURE_ERROR_BAD_PARAMETER,
            TextureError::Type => ffi::COGL_TEXTURE_ERROR_TYPE,
            TextureError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::CoglTextureError> for TextureError {
    fn from_glib(value: ffi::CoglTextureError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => TextureError::Size,
            1 => TextureError::Format,
            2 => TextureError::BadParameter,
            3 => TextureError::Type,
            value => TextureError::__Unknown(value),
        }
    }
}

impl ErrorDomain for TextureError {
    fn domain() -> Quark {
        skip_assert_initialized!();
        unsafe { from_glib(ffi::cogl_texture_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(TextureError::Size),
            1 => Some(TextureError::Format),
            2 => Some(TextureError::BadParameter),
            3 => Some(TextureError::Type),
            value => Some(TextureError::__Unknown(value)),
        }
    }
}

impl StaticType for TextureError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::cogl_texture_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for TextureError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for TextureError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for TextureError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum TextureType {
    _2d,
    _3d,
    Rectangle,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for TextureType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "TextureType::{}",
            match *self {
                TextureType::_2d => "_2d",
                TextureType::_3d => "_3d",
                TextureType::Rectangle => "Rectangle",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for TextureType {
    type GlibType = ffi::CoglTextureType;

    fn to_glib(&self) -> ffi::CoglTextureType {
        match *self {
            TextureType::_2d => ffi::COGL_TEXTURE_TYPE_2D,
            TextureType::_3d => ffi::COGL_TEXTURE_TYPE_3D,
            TextureType::Rectangle => ffi::COGL_TEXTURE_TYPE_RECTANGLE,
            TextureType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::CoglTextureType> for TextureType {
    fn from_glib(value: ffi::CoglTextureType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => TextureType::_2d,
            1 => TextureType::_3d,
            2 => TextureType::Rectangle,
            value => TextureType::__Unknown(value),
        }
    }
}

impl StaticType for TextureType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::cogl_texture_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for TextureType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for TextureType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for TextureType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum VerticesMode {
    Points,
    Lines,
    LineLoop,
    LineStrip,
    Triangles,
    TriangleStrip,
    TriangleFan,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for VerticesMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "VerticesMode::{}",
            match *self {
                VerticesMode::Points => "Points",
                VerticesMode::Lines => "Lines",
                VerticesMode::LineLoop => "LineLoop",
                VerticesMode::LineStrip => "LineStrip",
                VerticesMode::Triangles => "Triangles",
                VerticesMode::TriangleStrip => "TriangleStrip",
                VerticesMode::TriangleFan => "TriangleFan",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for VerticesMode {
    type GlibType = ffi::CoglVerticesMode;

    fn to_glib(&self) -> ffi::CoglVerticesMode {
        match *self {
            VerticesMode::Points => ffi::COGL_VERTICES_MODE_POINTS,
            VerticesMode::Lines => ffi::COGL_VERTICES_MODE_LINES,
            VerticesMode::LineLoop => ffi::COGL_VERTICES_MODE_LINE_LOOP,
            VerticesMode::LineStrip => ffi::COGL_VERTICES_MODE_LINE_STRIP,
            VerticesMode::Triangles => ffi::COGL_VERTICES_MODE_TRIANGLES,
            VerticesMode::TriangleStrip => ffi::COGL_VERTICES_MODE_TRIANGLE_STRIP,
            VerticesMode::TriangleFan => ffi::COGL_VERTICES_MODE_TRIANGLE_FAN,
            VerticesMode::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::CoglVerticesMode> for VerticesMode {
    fn from_glib(value: ffi::CoglVerticesMode) -> Self {
        skip_assert_initialized!();
        match value {
            0 => VerticesMode::Points,
            1 => VerticesMode::Lines,
            2 => VerticesMode::LineLoop,
            3 => VerticesMode::LineStrip,
            4 => VerticesMode::Triangles,
            5 => VerticesMode::TriangleStrip,
            6 => VerticesMode::TriangleFan,
            value => VerticesMode::__Unknown(value),
        }
    }
}

impl StaticType for VerticesMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::cogl_vertices_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for VerticesMode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for VerticesMode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for VerticesMode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum Winding {
    Clockwise,
    CounterClockwise,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for Winding {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Winding::{}",
            match *self {
                Winding::Clockwise => "Clockwise",
                Winding::CounterClockwise => "CounterClockwise",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for Winding {
    type GlibType = ffi::CoglWinding;

    fn to_glib(&self) -> ffi::CoglWinding {
        match *self {
            Winding::Clockwise => ffi::COGL_WINDING_CLOCKWISE,
            Winding::CounterClockwise => ffi::COGL_WINDING_COUNTER_CLOCKWISE,
            Winding::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::CoglWinding> for Winding {
    fn from_glib(value: ffi::CoglWinding) -> Self {
        skip_assert_initialized!();
        match value {
            0 => Winding::Clockwise,
            1 => Winding::CounterClockwise,
            value => Winding::__Unknown(value),
        }
    }
}

impl StaticType for Winding {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::cogl_winding_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for Winding {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for Winding {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for Winding {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum WinsysFeature {
    MultipleOnscreen,
    SwapThrottle,
    VblankCounter,
    VblankWait,
    TextureFromPixmap,
    SwapBuffersEvent,
    SwapRegion,
    SwapRegionThrottle,
    SwapRegionSynchronized,
    BufferAge,
    SyncAndCompleteEvent,
    NFeatures,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for WinsysFeature {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "WinsysFeature::{}",
            match *self {
                WinsysFeature::MultipleOnscreen => "MultipleOnscreen",
                WinsysFeature::SwapThrottle => "SwapThrottle",
                WinsysFeature::VblankCounter => "VblankCounter",
                WinsysFeature::VblankWait => "VblankWait",
                WinsysFeature::TextureFromPixmap => "TextureFromPixmap",
                WinsysFeature::SwapBuffersEvent => "SwapBuffersEvent",
                WinsysFeature::SwapRegion => "SwapRegion",
                WinsysFeature::SwapRegionThrottle => "SwapRegionThrottle",
                WinsysFeature::SwapRegionSynchronized => "SwapRegionSynchronized",
                WinsysFeature::BufferAge => "BufferAge",
                WinsysFeature::SyncAndCompleteEvent => "SyncAndCompleteEvent",
                WinsysFeature::NFeatures => "NFeatures",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl ToGlib for WinsysFeature {
    type GlibType = ffi::CoglWinsysFeature;

    fn to_glib(&self) -> ffi::CoglWinsysFeature {
        match *self {
            WinsysFeature::MultipleOnscreen => ffi::COGL_WINSYS_FEATURE_MULTIPLE_ONSCREEN,
            WinsysFeature::SwapThrottle => ffi::COGL_WINSYS_FEATURE_SWAP_THROTTLE,
            WinsysFeature::VblankCounter => ffi::COGL_WINSYS_FEATURE_VBLANK_COUNTER,
            WinsysFeature::VblankWait => ffi::COGL_WINSYS_FEATURE_VBLANK_WAIT,
            WinsysFeature::TextureFromPixmap => ffi::COGL_WINSYS_FEATURE_TEXTURE_FROM_PIXMAP,
            WinsysFeature::SwapBuffersEvent => ffi::COGL_WINSYS_FEATURE_SWAP_BUFFERS_EVENT,
            WinsysFeature::SwapRegion => ffi::COGL_WINSYS_FEATURE_SWAP_REGION,
            WinsysFeature::SwapRegionThrottle => ffi::COGL_WINSYS_FEATURE_SWAP_REGION_THROTTLE,
            WinsysFeature::SwapRegionSynchronized => {
                ffi::COGL_WINSYS_FEATURE_SWAP_REGION_SYNCHRONIZED
            }
            WinsysFeature::BufferAge => ffi::COGL_WINSYS_FEATURE_BUFFER_AGE,
            WinsysFeature::SyncAndCompleteEvent => {
                ffi::COGL_WINSYS_FEATURE_SYNC_AND_COMPLETE_EVENT
            }
            WinsysFeature::NFeatures => ffi::COGL_WINSYS_FEATURE_N_FEATURES,
            WinsysFeature::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::CoglWinsysFeature> for WinsysFeature {
    fn from_glib(value: ffi::CoglWinsysFeature) -> Self {
        skip_assert_initialized!();
        match value {
            0 => WinsysFeature::MultipleOnscreen,
            1 => WinsysFeature::SwapThrottle,
            2 => WinsysFeature::VblankCounter,
            3 => WinsysFeature::VblankWait,
            4 => WinsysFeature::TextureFromPixmap,
            5 => WinsysFeature::SwapBuffersEvent,
            6 => WinsysFeature::SwapRegion,
            7 => WinsysFeature::SwapRegionThrottle,
            8 => WinsysFeature::SwapRegionSynchronized,
            9 => WinsysFeature::BufferAge,
            10 => WinsysFeature::SyncAndCompleteEvent,
            11 => WinsysFeature::NFeatures,
            value => WinsysFeature::__Unknown(value),
        }
    }
}

impl StaticType for WinsysFeature {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::cogl_winsys_feature_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for WinsysFeature {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for WinsysFeature {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for WinsysFeature {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}
